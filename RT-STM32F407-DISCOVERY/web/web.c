/*
    ChibiOS/RT - Copyright (C) 2006,2007,2008,2009,2010,
                 2011,2012 Giovanni Di Sirio.

    This file is part of ChibiOS/RT.

    ChibiOS/RT is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    ChibiOS/RT is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/*
 * This file is a modified version of the lwIP web server demo. The original
 * author is unknown because the file didn't contain any license information.
 */

/**
 * @file web.c
 * @brief HTTP server wrapper thread code.
 * @addtogroup WEB_THREAD
 * @{
 */
#include "ch.h"
#include "osal.h"
#include "ArrayList.h"
#include "ITM_trace.h"
#include "chregistry.h"
#include "chprintf.h"

#include "lwip/opt.h"
#include "lwip/arch.h"
#include "lwip/api.h"
#include "inc/fs.h"
#include "web.h"
#include <string.h>

#include "mb_m.h"

/*	Exported variables	------------------------------------*/
extern ITMStream itm_port;
extern DeviceList list_RTC;

/*	Static variables  --------------------------------------*/
static __IO uint32_t 	DataFlag;
static __IO uint32_t 	size;
static __IO uint32_t 	TotalData;
static uint32_t 		ContentLengthOffset;
static uint32_t			BrowserFlag;
static uint32_t 		TotalReceived;

static const char http_crnl_2[4] = 
/* "\r\n--" */
{0xd, 0xa,0x2d,0x2d};
static const char octet_stream[14] = 
/* "octet-stream" */
{0x6f, 0x63, 0x74, 0x65, 0x74, 0x2d, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d,0x0d, };
static const char Content_Length[17] = 
/* Content Length */
{0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x4c, 0x65, 0x6e, 0x67,0x74, 0x68, 0x3a, 0x20, };

#if LWIP_NETCONN

 /* itoa: */
void itoa(int n, char s[])
{
	/* reverse: */
	void reverse(char s[])
	{
	    int i, j;
	    char c;

	    for (i = 0, j = strlen(s)-1; i<j; i++, j--)
	    {
	        c = s[i];
	        s[i] = s[j];
	        s[j] = c;
	    }
	}

	int i, sign;

    if ((sign = n) < 0)  /* */
        n = -n;          /* */
    i = 0;
    do {       /* */
        s[i++] = n % 10 + '0';   /* */
    } while ((n /= 10) > 0);     /* */
    if (sign < 0)
        s[i++] = '-';
    s[i] = '\0';
    reverse(s);
 }



/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
u32_t nPageHits = 0;

/* Format of dynamic web page: the page header */
static const unsigned char PAGE_START[] = {
	/*<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">*/
	0x3c,0x21,0x44,0x4f,0x43,0x54,0x59,0x50,0x45,0x20,0x68,0x74,0x6d,0x6c,0x20,0x50,
0x55,0x42,0x4c,0x49,0x43,0x20,0x22,0x2d,0x2f,0x2f,0x57,0x33,0x43,0x2f,0x2f,0x44,
0x54,0x44,0x20,0x48,0x54,0x4d,0x4c,0x20,0x34,0x2e,0x30,0x31,0x2f,0x2f,0x45,0x4e,
0x22,0x20,0x22,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x77,0x33,
0x2e,0x6f,0x72,0x67,0x2f,0x54,0x52,0x2f,0x68,0x74,0x6d,0x6c,0x34,0x2f,0x73,0x74,
0x72,0x69,0x63,0x74,0x2e,0x64,0x74,0x64,0x22,0x3e,
/*<html>*/
0x0d,0x0a,0x3c,0x68,0x74,0x6d,0x6c,0x3e,
/*<head>*/
0x0d,0x0a,0x3c,0x68,0x65,0x61,0x64,0x3e,
/*<title>ModBUSVerventa</title>*/
0x0d,0x0a,0x20,0x20,0x3c,0x74,0x69,0x74,0x6c,0x65,0x3e,
0x4d,0x6f,0x64,0x42,0x55,0x53,0x54,0x61,0x73,0x6b,0x73,0x56,0x65,0x72,0x76,0x65,
0x6e,0x74,0x61,0x3c,0x2f,0x74,0x69,0x74,0x6c,0x65,0x3e,
/*<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">*/
0x0d,0x0a,0x20,0x20,0x3c,0x6d,0x65,0x74,0x61,0x20,0x68,0x74,0x74,0x70,0x2d,0x65,
0x71,0x75,0x69,0x76,0x3d,0x22,0x43,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x2d,0x54,0x79,
0x70,0x65,0x22,0x0d,0x0a,0x20,0x63,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x3d,0x22,0x74,
0x65,0x78,0x74,0x2f,0x68,0x74,0x6d,0x6c,0x3b,0x20,0x63,0x68,0x61,0x72,0x73,0x65,
0x74,0x3d,0x77,0x69,0x6e,0x64,0x6f,0x77,0x73,0x2d,0x31,0x32,0x35,0x32,0x22,0x3e,
/*<meta http-equiv="refresh" content="1">*/
0x0d,0x0a,0x20,0x20,0x3c,0x6d,0x65,0x74,0x61,0x20,0x68,0x74,0x74,0x70,0x2d,0x65,
0x71,0x75,0x69,0x76,0x3d,0x22,0x72,0x65,0x66,0x72,0x65,0x73,0x68,0x22,0x20,0x63,
0x6f,0x6e,0x74,0x65,0x6e,0x74,0x3d,0x22,0x31,0x22,0x3e,
/*<meta content="MSHTML 6.00.2800.1561" name="GENERATOR">*/
0x0d,0x0a,0x20,0x20,0x3c,0x6d,0x65,0x74,0x61,0x20,0x63,0x6f,0x6e,0x74,0x65,0x6e,
0x74,0x3d,0x22,0x4d,0x53,0x48,0x54,0x4d,0x4c,0x20,0x36,0x2e,0x30,0x30,0x2e,0x32,
0x38,0x30,0x30,0x2e,0x31,0x35,0x36,0x31,0x22,0x20,0x6e,0x61,0x6d,0x65,0x3d,0x22,
0x47,0x45,0x4e,0x45,0x52,0x41,0x54,0x4f,0x52,0x22,0x3e,
/*<style ="font-weight: normal; font-family: Verdana;">*/
0x0d,0x0a,0x20,0x20,0x3c,0x73,0x74,0x79,0x6c,0x65,0x20,0x3d,0x22,0x66,0x6f,
0x6e,0x74,0x2d,0x77,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x6e,0x6f,0x72,0x6d,0x61,
0x6c,0x3b,0x20,0x66,0x6f,0x6e,0x74,0x2d,0x66,0x61,0x6d,0x69,0x6c,0x79,0x3a,0x20,
0x56,0x65,0x72,0x64,0x61,0x6e,0x61,0x3b,0x22,0x3e,
/*</style>
  </head>*/
0x3c,0x2f,0x73,0x74,0x79,0x6c,0x65,0x3e,0x0d,0x0a,0x3c,0x2f,0x68,0x65,0x61,0x64,
0x3e,
/*<body>
  <h4>*/
0x0d,0x0a,0x3c,0x62,0x6f,0x64,0x79,0x3e,0x0d,0x0a,0x3c,0x68,0x34,0x3e,
/*<small style="font-family: Verdana;"><small><big>*/
0x3c,0x73,0x6d,0x61,0x6c,0x6c,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,
0x6e,0x74,0x2d,0x66,0x61,0x6d,0x69,0x6c,0x79,0x3a,0x20,0x56,0x65,0x72,0x64,0x61,
0x6e,0x61,0x3b,0x22,0x3e,0x3c,0x73,0x6d,0x61,0x6c,0x6c,0x3e,0x3c,0x62,0x69,0x67,
0x3e,
/*<big>*/
0x3c,0x62,0x69,0x67,0x3e,
/*<big style="font-weight: bold;">*/
0x3c,0x62,0x69,0x67,0x0d,0x0a,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,
0x6e,0x74,0x2d,0x77,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x62,0x6f,0x6c,0x64,0x3b,
0x22,0x3e,
/*<big><strong><em>*/
0x3c,0x62,0x69,0x67,0x3e,0x3c,0x73,0x74,0x72,0x6f,0x6e,0x67,0x3e,
0x3c,0x65,0x6d,0x3e,
/*<span style="font-style: italic;">*/
0x3c,0x73,0x70,0x61,0x6e,0x0d,0x0a,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,
0x22,0x66,0x6f,0x6e,0x74,0x2d,0x73,0x74,0x79,0x6c,0x65,0x3a,0x20,0x69,0x74,0x61,
0x6c,0x69,0x63,0x3b,0x22,0x3e,
/*Verventa Modbus Devices Status*/
0x56,0x65,0x72,0x76,0x65,0x6e,0x74,0x61,0x20,0x4d,0x6f,0x64,0x62,0x75,0x73,0x20, 
0x44,0x65,0x76,0x69,0x63,0x65,0x73,0x20,0x53,0x74,0x61,0x74,0x75,0x73,
/*</span></em>*/
0x3c,0x2f,0x73,0x70,0x61,0x6e,0x3e,0x3c,0x2f,0x65,0x6d,0x3e,
/*</strong></big>*/
0x3c,0x2f,0x73,0x74,0x72,0x6f,0x6e,0x67,0x3e,0x3c,0x2f,0x62,0x69,0x67,0x3e,
/*</big>*/
0x3c,0x2f,0x62,0x69,0x67,0x3e,
/*</big></big>*/
0x3c,0x2f,0x62,0x69,0x67,0x3e,0x3c,0x2f,0x62,0x69,0x67,0x3e,
/*</small></small>*/
0x3c,0x2f,0x73,0x6d,0x61,0x6c,0x6c,0x3e,0x3c,0x2f,0x73,0x6d,0x61,0x6c,0x6c,0x3e,
/*</h4>*/
0x3c,0x2f,0x68,0x34,0x3e,
/*<hr style="width: 100%; height: 2px;">*/
0x0d,0x0a,0x3c,0x68,0x72,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x77,0x69,0x64,
0x74,0x68,0x3a,0x20,0x31,0x30,0x30,0x25,0x3b,0x20,0x68,0x65,0x69,0x67,0x68,0x74,
0x3a,0x20,0x32,0x70,0x78,0x3b,0x22,0x3e,
/*<span style="font-weight: bold;">*/
0x3c,0x73,0x70,0x61,0x6e,0x0d,0x0a,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,
0x6f,0x6e,0x74,0x2d,0x77,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x62,0x6f,0x6c,0x64,
0x3b,0x22,0x3e,
/*</span>*/
0x0d,0x0a,0x3c,0x2f,0x73,0x70,0x61,0x6e,0x3e,
/*<span style="font-weight: bold;">*/
0x3c,0x73,0x70,0x61,0x6e,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,
0x74,0x2d,0x77,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x62,0x6f,0x6c,0x64,0x3b,0x22,
0x3e,
/*<table style="width: 961px; height: 30px;" border="1" cellpadding="2" cellspacing="2">*/
0x0d,0x0a,0x3c,0x74,0x61,0x62,0x6c,0x65,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,
0x77,0x69,0x64,0x74,0x68,0x3a,0x20,0x39,0x36,0x31,0x70,0x78,0x3b,0x20,0x68,0x65,
0x69,0x67,0x68,0x74,0x3a,0x20,0x33,0x30,0x70,0x78,0x3b,0x22,0x20,0x62,0x6f,0x72,
0x64,0x65,0x72,0x3d,0x22,0x31,0x22,0x0d,0x0a,0x20,0x63,0x65,0x6c,0x6c,0x70,0x61,
0x64,0x64,0x69,0x6e,0x67,0x3d,0x22,0x32,0x22,0x20,0x63,0x65,0x6c,0x6c,0x73,0x70,
0x61,0x63,0x69,0x6e,0x67,0x3d,0x22,0x32,0x22,0x3e,
/*<tbody>*/
0x0d,0x0a,0x20,0x20,0x3c,0x74,0x62,0x6f,0x64,0x79,0x3e,
/*<tr>*/
0x0d,0x0a,0x20,0x20,0x20,0x20,0x3c,0x74,0x72,0x3e,
/*<td 
style="font-family: Verdana; font-weight: bold; font-style: italic; background-color: rgb(51, 51, 255); text-align: center;">*/
0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x74,0x64,
0x0d,0x0a,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,0x74,0x2d,0x66,
0x61,0x6d,0x69,0x6c,0x79,0x3a,0x20,0x56,0x65,0x72,0x64,0x61,0x6e,0x61,0x3b,0x20,
0x66,0x6f,0x6e,0x74,0x2d,0x77,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x62,0x6f,0x6c,
0x64,0x3b,0x20,0x66,0x6f,0x6e,0x74,0x2d,0x73,0x74,0x79,0x6c,0x65,0x3a,0x20,0x69,
0x74,0x61,0x6c,0x69,0x63,0x3b,0x20,0x62,0x61,0x63,0x6b,0x67,0x72,0x6f,0x75,0x6e,
0x64,0x2d,0x63,0x6f,0x6c,0x6f,0x72,0x3a,0x20,0x72,0x67,0x62,0x28,0x35,0x31,0x2c,
0x20,0x35,0x31,0x2c,0x20,0x32,0x35,0x35,0x29,0x3b,0x20,0x74,0x65,0x78,0x74,0x2d,
0x61,0x6c,0x69,0x67,0x6e,0x3a,0x20,0x63,0x65,0x6e,0x74,0x65,0x72,0x3b,0x22,0x3e,
/*<small>*/
0x3c,0x73,0x6d,0x61,0x6c,0x6c,0x3e,
/*<a
href="/Verventa_Master.html">*/
0x3c,0x61,0x0d,0x0a,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x2f,0x56,0x65,0x72,0x76,
0x65,0x6e,0x74,0x61,0x5f,0x4d,0x61,0x73,0x74,0x65,0x72,0x2e,0x68,0x74,0x6d,0x6c,
0x22,0x3e,
/*<span style="color: white;">*/
0x3c,0x73,0x70,0x61,0x6e,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x63,0x6f,0x6c,
0x6f,0x72,0x3a,0x20,0x77,0x68,0x69,0x74,0x65,0x3b,0x22,0x3e,
/*Home
page</span>*/
0x48,0x6f,0x6d,0x65,0x0d,0x0a,0x70,0x61,0x67,0x65,0x3c,0x2f,0x73,0x70,0x61,0x6e,
0x3e,
/*</a>*/
0x3c,0x2f,0x61,0x3e,
/*</small>*/
0x3c,0x2f,0x73,0x6d,0x61,0x6c,0x6c,0x3e,
/*</td>*/
0x3c,0x2f,0x74,0x64,0x3e,
/*</tr>*/
0x0d,0x0a,0x20,0x20,0x20,0x20,0x3c,0x2f,0x74,0x72,0x3e,
/*</tbody>*/
0x0d,0x0a,0x20,0x20,0x3c,
0x2f,0x74,0x62,0x6f,0x64,0x79,0x3e,
/*</table>*/
0x0d,0x0a,0x3c,0x2f,0x74,0x61,0x62,0x6c,0x65,
0x3e,
/*<br>*/
0x0d,0x0a,0x3c,0x62,0x72,0x3e,
/*</span>*/
0x0d,0x0a,0x3c,0x2f,0x73,0x70,0x61,0x6e,0x3e,
/*<span style="font-weight: bold;">*/
0x3c,0x73,0x70,0x61,0x6e,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,
0x74,0x2d,0x77,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x62,0x6f,0x6c,0x64,0x3b,0x22,
0x3e,
/*</span>*/
0x3c,0x2f,0x73,0x70,0x61,0x6e,0x3e,
/*<small>*/
0x3c,0x73,0x6d,0x61,0x6c,0x6c,0x3e,
/*<span
style="font-family: Verdana;">*/
0x3c,0x73,0x70,0x61,0x6e,0x0d,0x0a,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,
0x6f,0x6e,0x74,0x2d,0x66,0x61,0x6d,0x69,0x6c,0x79,0x3a,0x20,0x56,0x65,0x72,0x64,
0x61,0x6e,0x61,0x3b,0x22,0x3e,
/*Number of page hits:*/
0x4e,0x75,0x6d,0x62,0x65,0x72,0x20,0x6f,0x66,0x20,0x70,
0x61,0x67,0x65,0x20,0x68,0x69,0x74,0x73,0x3a,0x0d,0x0a,0x00
};

/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/
/**
  * @brief  Create and send a dynamic Web Page. This page contains the list of
  *         running tasks and the number of page hits.
  * @param  conn pointer on connection structure
  * @retval None
  */
void DynWebPage(struct netconn *conn)
{
  char PAGE_BODY[1024];
  char pagehits[10] = {0};
  memset(PAGE_BODY, 0,1024);

  char TABLE_HEAD[130];
  memset(TABLE_HEAD, 0,130);

  /* Update the hit count */
  nPageHits++;

  itoa(nPageHits, pagehits);
  strcat(TABLE_HEAD, pagehits);
  strcat(TABLE_HEAD, "<br><br>");

  strcat((char *)TABLE_HEAD,
		  "<table><thead><tr><td><b>name<td><b>addr<td><b>stack<td><b>prio<td><b>refs<td><b>state<td><b>time</tr></thead></b>" );

  thread_t *tp;
  char mes[50];
  const char * tr = "<tr>";
  const char * td = "<td>";
  const char * trc = "</tr>";
  
  tp = chRegFirstThread();
  do{
	  strcat((char *)PAGE_BODY, tr);

	  strcat((char *)PAGE_BODY, td);
	  strcat((char *)PAGE_BODY, tp->p_name);

	  strcat((char *)PAGE_BODY, td);
	  itoa((uint32_t)tp, mes);
	  strcat((char *)PAGE_BODY, mes);

	  strcat((char *)PAGE_BODY, td);
	  itoa((uint32_t)(uint32_t)tp->p_ctx.r13, mes);
	  strcat((char *)PAGE_BODY, mes);

	  strcat((char *)PAGE_BODY, td);
	  itoa((uint32_t)tp->p_prio, mes);
	  strcat((char *)PAGE_BODY, mes);

	  strcat((char *)PAGE_BODY, td);
	  itoa((uint32_t)(tp->p_refs - 1), mes);
	  strcat((char *)PAGE_BODY, mes);

	  strcat((char *)PAGE_BODY, td);
	  //strcat((char *)PAGE_BODY,states[tp->p_state]);
	  strcat((char *)PAGE_BODY, " ");

	  strcat((char *)PAGE_BODY, td);
	  //itoa((uint32_t)tp->p_time, mes);
	  strcat((char *)PAGE_BODY, mes);

	  strcat((char *)PAGE_BODY, trc);
	  
	  tp = chRegNextThread(tp);
  }
  while(tp != NULL);
  strcat((char *)PAGE_BODY, "</table>" );

  // Send the dynamically generated page
  netconn_write(conn, PAGE_START, strlen((char*)PAGE_START), NETCONN_COPY);
  netconn_write(conn, TABLE_HEAD, strlen((char*)TABLE_HEAD), NETCONN_COPY);
  netconn_write(conn, PAGE_BODY,  strlen(PAGE_BODY), 		 NETCONN_COPY);
}

/**
  * @brief  Create and send a dynamic Web Page. This page contains the list of
  *         running modbus slaves.
  * @param  conn pointer on connection structure
  * @retval None
  */
void DynWebPage_ModbusStat(struct netconn *conn)
{
  DeviceElement* e;
  uint8_t index = 0;

  char PAGE_BODY[1024];
  char pagehits[10] = {0};
  memset(PAGE_BODY, 0,1024);

  char TABLE_HEAD[256];
  memset(TABLE_HEAD, 0,256);

  /* Update the hit count */
  nPageHits++;

  itoa(nPageHits, pagehits);
  strcat(TABLE_HEAD, pagehits);
  strcat(TABLE_HEAD, "<br><br>");

  strcat((char *)TABLE_HEAD,
		"<table><tr><thead><th>name<th>address<th>state<th>reqTimeOut<th>requests<th>function<th>regStart<th>regCount<th>AHU<th>HRU</thead></tr>" );

  char mes[50];
  const char * tr = "<tr>";
  const char * td = "<td>";
  const char * trc = "</tr>";
  
  do{
	  chprintf((BaseSequentialStream *)&itm_port, "index: %d\n", index);
	  e = get(&list_RTC, index++);
	  
	  strcat((char *)PAGE_BODY, tr);

	  strcat((char *)PAGE_BODY, td);
	  strcat((char *)PAGE_BODY, (e->name));
	  strcat((char *)PAGE_BODY, "</td>");

	  strcat((char *)PAGE_BODY, td);
	  itoa((e->address), mes);
	  strcat((char *)PAGE_BODY, mes);
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
	  if(e->state == 0)
	  {
		strcat((char *)PAGE_BODY, "CONNECTED");
	  }else{
		strcat((char *)PAGE_BODY, "CONNECTIONLESS");
	  }
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
	  itoa((e->TimeOut_request), mes);
	  strcat((char *)PAGE_BODY, mes);
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
	  itoa((e->requests), mes);
	  strcat((char *)PAGE_BODY, mes);
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
	  itoa((e->function), mes);
	  strcat((char *)PAGE_BODY, mes);
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
	  itoa((e->regStart), mes);
	  strcat((char *)PAGE_BODY, mes);
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
	  itoa((e->regCount), mes);
	  strcat((char *)PAGE_BODY, mes);
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
	  itoa((e->AHU_address), mes);
	  strcat((char *)PAGE_BODY, mes);
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
	  itoa((e->HRU_address), mes);
	  strcat((char *)PAGE_BODY, mes);
	  strcat((char *)PAGE_BODY, "</td>");

	  strcat((char *)PAGE_BODY, trc);
  }
  while(index <= list_RTC.current);
  
  strcat((char *)PAGE_BODY, "</table>" );
  
  //chprintf((BaseSequentialStream *)&itm_port, "PAGE_BODY: %s\n", PAGE_BODY);

  // Send the dynamically generated page
  netconn_write(conn, PAGE_START, strlen((char*)PAGE_START), NETCONN_COPY);
  netconn_write(conn, TABLE_HEAD, strlen((char*)TABLE_HEAD), NETCONN_COPY);
  netconn_write(conn, PAGE_BODY,  strlen(PAGE_BODY), 		 NETCONN_COPY);
}



/**
  * @brief serve tcp connection
  * @param conn: pointer on connection structure
  * @retval None
  */
void http_server_serve(struct netconn *conn)
{
  struct netbuf*	inbuf;
  char* 			buf;
  char*				ptr;
  char*				filename[13];
  uint16_t 			buflen;
  struct fs_file * 	file;
  uint32_t 			DataOffset;
  uint32_t			FilenameOffset;
  int32_t 			i = 0;
  err_t 			err;
  // Read the data from the port, blocking if nothing yet there.
  // We assume the request (the part we care about) is in one netbuf
  err = netconn_recv(conn, &inbuf);

  if (inbuf != NULL)
  {
    if (err == ERR_OK)
    {
      netbuf_data(inbuf, (void**)&buf, &buflen);
	  chprintf((BaseSequentialStream *)&itm_port, "buflen: %i\n buf: %s\n", buflen, buf);

      /* Is this an HTTP GET command? (only check the first 5 chars, since
      there are other formats for GET, and we're keeping it very simple )*/
      if ((buflen >=5) && (strncmp(buf, "GET /", 5) == 0))
      {
        /* Check if request to get climate-control.jpg */
        if (strncmp((char const *)buf,"GET /assets/splash_screen.jpg",25)==0)
        {
          file = fs_open("/img/splash_screen.jpg");
          netconn_write(conn, (const unsigned char*)(file->data), (size_t)file->len, NETCONN_NOCOPY);
          fs_close(file);
        }
		/* Load dynamic page */
        else if(strncmp(buf, "GET /STM32F4x7TASKS.html", 24) == 0)
        {
           DynWebPage(conn);
        }
		else if(strncmp(buf, "GET /MODBUSTASKS.html", 21) == 0)
        {
           DynWebPage_ModbusStat(conn);
        }
		else if(strncmp(buf, "GET /uploadconfig.html", 22) == 0)
        {
		   file = fs_open("/uploadconfig.html");
           netconn_write(conn, (const unsigned char*)(file->data), (size_t)file->len, NETCONN_NOCOPY);
           fs_close(file);
        }
		/* Load index page */
        else if((strncmp(buf, "GET /Verventa_Master.html", 15) == 0)||(strncmp(buf, "GET / ", 6) == 0))
        {
          file = fs_open("/Verventa_Master.html");
          netconn_write(conn, (const unsigned char*)(file->data), (size_t)file->len, NETCONN_NOCOPY);
          fs_close(file);
        }
		/* process POST request for file upload and incoming data packets after POST request*/
		else if((strncmp(buf, "POST /upload.cgi", 16) == 0) || (DataFlag >= 1))
		{
			chprintf((BaseSequentialStream *)&itm_port, "%s\n", "start upload file...");
			DataOffset = 0;
        
			/* POST Packet received */
			if(DataFlag == 0)
			{
				BrowserFlag = 0;
			    TotalReceived = 0;
          
			    /* parse packet for Content-length field */
			    //size = Parse_Content_Length(buf, (uint32_t)(buflen));
           
			    /* parse packet for the octet-stream field */
                for(i = 0; i < buflen; i++)
                {
                    if(strncmp((char*)(buf + i), octet_stream, 13) == 0)
                    {
						DataOffset = i + 16;
						break;
                    }
                }
                /* case of MSIE8 : we do not receive data in the POST packet*/ 
                if(DataOffset == 0)
                {
					DataFlag++;
					BrowserFlag = 1;
				 
					return ERR_OK;
			    }
                /* case of Mozilla Firefox : we receive data in the POST packet*/
                else
                {
					//TotalReceived = buflen - (ContentLengthOffset + 4);
                }
            }
			/* For MSIE8 and Mozilla Firefox */
            if(((DataFlag == 1) && (BrowserFlag == 1)) || ((DataFlag == 0) && (BrowserFlag == 0)))
            {
                if((DataFlag == 0) && (BrowserFlag == 0))
                {
					DataFlag++;
                }
                else if((DataFlag == 1) && (BrowserFlag == 1))
                {
                    /* parse packet for the octet-stream field */
                    for (i = 0; i < buflen; i++)
                    {
                        if(strncmp((char*)(buf + i), octet_stream, 13) == 0)
                        {
							DataOffset = i + 16;
							break;
                        }
                    }
                    TotalReceived += buflen;
                    DataFlag++;
                }  
                
                /* parse packet for the filename field */
                FilenameOffset = 0;
                for(i = 0; i < buflen; i++)
                {
                    if(strncmp((char*)(buf + i), "filename=", 9) == 0)
                    {
						FilenameOffset = i + 10;
						break;
                    }
                }
				
				i = 0;
				
				if(FilenameOffset)
				{
					while((*(buf + FilenameOffset + i) != 0x22 ) && (i < 13))
					{
						filename[i] = *(buf + FilenameOffset + i);
						i++;
					}
					filename[i] = 0x0;
					
					chprintf((BaseSequentialStream *)&itm_port, "filename: %s\n", buflen, filename);
				}
           
				if(i == 0)
				{
					/* no filename, in this case reload upload page */
					file = fs_open("/uploadconfig.html");
					netconn_write(conn, (const unsigned char*)(file->data), (size_t)file->len, NETCONN_NOCOPY);
					fs_close(file);
          
					/* Tell TCP that we wish be to informed of data that has been
					successfully sent by a call to the http_sent() function. */
					//tcp_sent(pcb, http_sent); 
					DataFlag = 0;
					
					return ERR_OK;
				}
			}
			/* DataFlag > 1 => the packet is data only  */
			else 
			{
				TotalReceived += buflen;
			}
        
			ptr = (char*)(buf + DataOffset);
			buflen -= DataOffset;
        
			/* update Total data received counter */
			TotalData += buflen;
        
			/* check if last data packet */
			if(TotalReceived == size)
			{
				/* if last packet need to remove the http boundary tag */
				/* parse packet for "\r\n--" starting from end of data */
				i = 4;
				while(strncmp((char*)(buf + buflen - i), http_crnl_2 , 4))
				{
					i++;
				}
		   
				buflen -= i;
				TotalData -= i;
				
				DataFlag = 0;
		   
				/* send uploaddone.html page */
				//fs_open("/uploaddone.html", &file);
          
				/* Tell TCP that we wish be to informed of data that has been
				successfully sent by a call to the http_sent() function. */
				//tcp_sent(pcb, http_sent);  
			}
			/* not last data packet */
			else
			{
				chprintf((BaseSequentialStream *)&itm_port, "%s\n", "not last data package...\n");
			}
		}
		/* Load Error page */
        else
        {
          chprintf((BaseSequentialStream *)&itm_port, "%s\n", "/404.html");
          file = fs_open("/404.html");
          netconn_write(conn, (const unsigned char*)(file->data), (size_t)file->len, NETCONN_NOCOPY);
          fs_close(file);
        }
      }
    }
  }
  /* Close the connection (server closes in HTTP) */
  netconn_close(conn);

  /* Delete the buffer (netconn_recv gives us ownership,
   so we have to make sure to deallocate the buffer) */
  netbuf_delete(inbuf);
}


/**
 * Stack area for the http thread.
 */
THD_WORKING_AREA(wa_http_server, WEB_THREAD_STACK_SIZE);

/**
 * HTTP server thread.
 */
msg_t http_server(void *p)
{
  struct netconn *conn, *newconn;
  err_t err;

  (void)p;

  /* Create a new TCP connection handle */
  conn = netconn_new(NETCONN_TCP);
  LWIP_ERROR("http_server: invalid conn", (conn != NULL), return MSG_RESET;);

  /* Bind to port 80 (HTTP) with default IP address */
  netconn_bind(conn, NULL, WEB_THREAD_PORT);

  /* Put the connection into LISTEN state */
  netconn_listen(conn);

  /* Goes to the final priority after initialization.*/
  chThdSetPriority(WEB_THREAD_PRIORITY);

  while(1) {
    err = netconn_accept(conn, &newconn);
    if (err != ERR_OK)
      continue;
    http_server_serve(newconn);
    netconn_delete(newconn);
  }
  return MSG_OK;
}

#endif /* LWIP_NETCONN */

/** @} */
